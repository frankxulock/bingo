import { IWindow } from "../../../Common/Tools/PopupSystem/IWindow";
import { PopupName } from "../../../Common/Tools/PopupSystem/PopupConfig";
import PopupManager from "../../../Common/Tools/PopupSystem/PopupManager";

const {ccclass, property} = cc._decorator;

interface ContentItem {
    type: 'text' | 'image' | 'prefab';
    content?: string;
    prefab?: cc.Prefab;
    imagePath?: string;
}

@ccclass
export default class HelpCenterPage extends cc.Component implements IWindow {
    
    @property(cc.ScrollView)
    scrollView: cc.ScrollView = null;

    @property(cc.Prefab)
    textBlockPrefab: cc.Prefab = null;

    @property(cc.Prefab)
    winningPatternsPrefab: cc.Prefab = null;

    @property(cc.Node)
    contentContainer: cc.Node = null;

    // 将长内容分段以提高性能
    private contentChunks: ContentItem[][] = [];
    private currentChunkIndex: number = 0;
    private isLoading: boolean = false;
    private isAutoLoading: boolean = false;
    private scrollThreshold: number = 0.70; // 滚动到70%时触发加载
    private generatedNodes: cc.Node[] = []; // 存储已生成的节点

    open(data?: any): void { 
        this.initializeContentChunks();
        this.setupScrollView();
        this.generateContent(0);
    }
    close?(): void {
        PopupManager.closePopup(PopupName.HelpCenterPage);
    }

    /**
     * 初始化内容分段
     */
    private initializeContentChunks(): void {
        // 第一段：游戏规则基础
        this.contentChunks[0] = [
            {
                type: 'text',
                content: `<b><size=20>Game Rules Description</size></b>

<b><size=18>Bingo Card Specifications:</size></b>

• Each card has a 5x5 grid; each square contains one number, except for the center square which is a "Free Space" and is auto-filled.

• A single card uses numbers from 1 to 75, with no duplicate numbers.

• <b>Number ranges by column (from left to right):</b>
  - <b>Column B:</b> 5 random numbers from 1 to 15
  - <b>Column I:</b> 5 random numbers from 16 to 30
  - <b>Column N:</b> 4 random numbers from 31 to 45 (center square is a Free Space)
  - <b>Column G:</b> 5 random numbers from 46 to 60
  - <b>Column O:</b> 5 random numbers from 61 to 75`
            }
        ];

        // 第二段：游戏模式
        this.contentChunks[1] = [
            {
                type: 'text',
                content: `<b><size=18>Random Number Explanation:</size></b>

A standard 5x5 bingo card (including the Free Space) is generated by selecting 24 numbers randomly from 1 to 75, based on the above column rules.

Players may also create their own preferred cards (DIY cards) to play.


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

<b><size=20>Game Modes:</size></b>

There are two game modes available:

<b>1. Extra Patterns</b>
<b>2. Bingo & Jackpot</b>

Players may choose to participate in either or both modes. Each mode requires a separate participation fee.`
            }
        ];

        // 第三段：游戏模式详细说明
        this.contentChunks[2] = [
            {
                type: 'text',
                content: `<b><size=18>1. Extra Patterns Mode</size></b>

• A total of <b>44 balls</b> will be drawn.

• If the player completes one of the specific winning patterns within the 44 drawn balls, they will win a prize.


<b><size=18>2. Bingo & Jackpot Mode</size></b>

There are two sub-types:

<b>a) Jackpot</b>
   Awarded when a player completes a Blackout pattern (i.e., all 24 numbers) within <b>44 balls or fewer</b>.

<b>b) Bingo</b>
   Awarded when a player completes a Blackout pattern within <b>49 balls or fewer</b>.`
            }
        ];

        // 第四段：游戏流程
        this.contentChunks[3] = [
            {
                type: 'text',
                content: `<b>Consolation prizes (1TG and 2TG)</b> are given to players who are 1 or 2 numbers away from completing a Blackout, but only if no player wins the Bingo. If there is a Bingo winner, no 1TG or 2TG prizes are issued.


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

<b><size=20>Game Flow:</size></b>

• The game will always draw at least <b>44 balls</b> (for Extra Pattern completion), and up to <b>49 balls</b> (for Bingo game completion).

• If a Bingo win is achieved before 44 balls (e.g., at ball 42), the draw will still continue to complete all 44 balls to finish the Extra Pattern game.

• If a player completes Blackout only on ball 43 or 44, it does not qualify for Bingo.`
            }
        ];

        // 第五段：中奖图案预览和奖品说明
        this.contentChunks[4] = [
            {
                type: 'text',
                content: `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

<b><size=20>Gameplay Instructions:</size></b>

• This page displays the number of cards players can select. Players may choose from randomly generated cards or use their custom (DIY) cards from the bottom right.

• Players can opt to join Extra Patterns, Bingo & Jackpot, or both modes simultaneously.

• In Extra Patterns mode, players can use the <b>(-)/(+)</b> icons to adjust their play quantity from <b>5 to 500</b>. The prize value increases proportionally (1x to 100x) based on the number of plays.`
            },
            {
                type: 'prefab',
                prefab: this.winningPatternsPrefab
            },
            {
                type: 'text',
                content: `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

<b><size=20>Prizes:</size></b>

• Prizes are awarded based on completing specific patterns within 44 balls.

• Prizes for <b>2L, 3L, and 4L</b> patterns are counted only for horizontal line combinations.

• If overlapping winning patterns occur, only the highest value pattern is paid. For example, if the player hits an <b>"X"</b> pattern, the diagonals "\" and "/" will not be paid separately.

• Only players who joined Bingo & Jackpot mode are eligible for Bingo & Jackpot prizes.`
            }
        ];

        // 第六段：奖金详情
        this.contentChunks[5] = [
            {
                type: 'text',
                content: `<b><size=18>Bingo Prize:</size></b>

• Initial prize pool: <b>PHP 500,000</b>

• Bingo winners will receive the entire prize pool.

• Players must complete a Blackout before or during the 49-ball draw to win the full prize.

• If no Bingo winner is found, 1TG and 2TG players will share a portion of the prize pool.

• If multiple players win at the same time, the prize will be equally divided.


<b><size=18>Jackpot:</size></b>

• Initial prize pool: <b>PHP 5,000,000</b>

• Only players who complete Blackout within 44 balls or fewer will win the Jackpot.

• If multiple players win the Jackpot, the prize is equally divided.


<b><size=18>Extra Balls:</size></b>

• This feature is only available for Bingo & Jackpot players.

• A maximum of <b>5 extra balls</b> can be awarded for free.`
            }
        ];

        // 第七段：玩法说明
        this.contentChunks[6] = [
            {
                type: 'text',
                content: `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

<b><size=20>How to Play the Bingo Game:</size></b>

Match all <b>24 numbers</b> within the <b>49 drawn balls</b>, and you will win the <b>Bingo Prize</b>, which is 100% funded from the Bingo Prize Pool.


<b><size=18>Bingo 1TG:</size></b>

If no one wins the Bingo, and you match <b>23 out of 24 numbers</b> within 49 balls (1 number remaining), you will win the Bingo 1TG (1 to go) prize of <b>PHP 2,500</b>.


<b><size=18>Bingo 2TG:</size></b>

If no one wins the Bingo, and you match <b>22 out of 24 numbers</b> within 49 balls (2 numbers remaining), you will win the Bingo 2TG (2 to go) prize of <b>PHP 200</b>.


<b>Note:</b> The 1TG and 2TG Bingo prizes only apply if no player wins Bingo within the 49 balls.`
            }
        ];

        // 第八段：预购说明
        this.contentChunks[7] = [
            {
                type: 'text',
                content: `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

<b><size=20>How to Play the Jackpot:</size></b>

Match all <b>24 numbers</b> within the first <b>44 drawn balls</b>, and you will win the <b>JACKPOT</b>, which is 100% funded from the Jackpot Prize Pool.


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

<b><size=20>How to Play Extra Patterns Mode:</size></b>

Match a specific pattern from the drawn balls to win the corresponding prize.

<b>Note:</b> If multiple overlapping patterns are hit, only the highest-value pattern is paid.

For example: If a player completes an X pattern, the \ and / patterns will not be paid separately.


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

<b><size=18>Pre-buy (Advance Card Purchase):</size></b>

• If a player does not buy a Bingo card during the current round, they can pre-purchase cards for the next round. The balance will be deducted immediately.

• Pre-purchased Bingo cards will be automatically applied in the next round.

• If the game cannot proceed after pre-purchase due to maintenance, the pre-purchased Bingo cards will be automatically carried over to the next round within three days after maintenance.

• If the player does not log in within three days, they will need to contact customer service for a refund.`
            }
        ];
    }

    /**
     * 设置ScrollView监听
     */
    private setupScrollView(): void {
        if (this.scrollView) {
            // 监听滚动事件
            this.scrollView.node.on('scroll-to-bottom', this.onScrollToBottom, this);
            this.scrollView.node.on('scrolling', this.onScrolling, this);
        }
    }

    /**
     * 滚动事件处理
     */
    private onScrolling(): void {
        if (!this.scrollView || this.isLoading || this.isAutoLoading) return;

        const scrollOffset = this.scrollView.getScrollOffset();
        const maxScrollOffset = this.scrollView.getMaxScrollOffset();
        
        // 计算滚动进度
        const scrollProgress = Math.abs(scrollOffset.y) / Math.abs(maxScrollOffset.y);
        
        // 当滚动到阈值时，自动加载下一段
        if (scrollProgress >= this.scrollThreshold && this.hasNextChunk()) {
            this.autoLoadNextChunk();
        }
    }

    /**
     * 滚动到底部事件
     */
    private onScrollToBottom(): void {
        if (!this.isLoading && this.hasNextChunk()) {
            this.autoLoadNextChunk();
        }
    }

    /**
     * 自动加载下一段
     */
    private autoLoadNextChunk(): void {
        if (this.isAutoLoading || !this.hasNextChunk()) return;
        
        this.isAutoLoading = true;
        
        // 延迟一下给用户加载感觉
        this.scheduleOnce(() => {
            this.appendNextChunk();
        }, 0.5);
    }

    /**
     * 追加下一段内容
     */
    private appendNextChunk(): void {
        if (this.currentChunkIndex >= this.contentChunks.length - 1) {
            this.isAutoLoading = false;
            return;
        }

        const nextChunkIndex = this.currentChunkIndex + 1;
        this.generateContent(nextChunkIndex, true);
        this.currentChunkIndex = nextChunkIndex;
        
        this.isAutoLoading = false;
        
        // 确保ScrollView的content尺寸更新
        this.scheduleOnce(() => {
            if (this.scrollView) {
                this.scrollView.content.getComponent(cc.Layout)?.updateLayout();
            }
        }, 0.1);
    }

    /**
     * 生成内容
     * @param chunkIndex 分段索引
     * @param append 是否追加模式
     */
    private generateContent(chunkIndex: number, append: boolean = false): void {
        if (chunkIndex >= this.contentChunks.length || !this.contentContainer) {
            return;
        }

        // 如果不是追加模式，清理之前生成的内容
        if (!append) {
            this.clearGeneratedNodes();
            this.currentChunkIndex = chunkIndex;
        }

        const chunk = this.contentChunks[chunkIndex];
        
        chunk.forEach((item: ContentItem) => {
            let node: cc.Node = null;

            switch (item.type) {
                case 'text':
                    node = this.createTextNode(item.content);
                    break;
                case 'prefab':
                    if (item.prefab || this.winningPatternsPrefab) {
                        node = cc.instantiate(item.prefab || this.winningPatternsPrefab);
                    }
                    break;
                case 'image':
                    node = this.createImageNode(item.imagePath);
                    break;
            }

            if (node) {
                this.contentContainer.addChild(node);
                this.generatedNodes.push(node);
            }
        });

        // 重置滚动位置（仅在非追加模式下）
        if (!append && this.scrollView) {
            this.scrollView.scrollToTop(0.3);
        }
    }

    /**
     * 创建文本节点
     */
    private createTextNode(content: string): cc.Node {
        let textNode: cc.Node;

        if (this.textBlockPrefab) {
            // 使用预制的文本块
            textNode = cc.instantiate(this.textBlockPrefab);
            const richText = textNode.getComponent(cc.RichText);
            if (richText) {
                richText.string = content;
                richText.maxWidth = 236;
                richText.lineHeight = 24;
                richText.fontSize = 14;
                richText.cacheMode = cc.Label.CacheMode.CHAR;
                
                // 设置混合模式防止颜色受后方视频影响
                this.setTextBlendMode(richText);
            }
        } else {
            // 创建默认的文本节点
            textNode = new cc.Node('TextBlock');
            const richText = textNode.addComponent(cc.RichText);
            richText.string = content;
            richText.maxWidth = 236;
            richText.lineHeight = 24;
            richText.fontSize = 14;
            richText.cacheMode = cc.Label.CacheMode.CHAR;
            
            // 设置混合模式防止颜色受后方视频影响
            this.setTextBlendMode(richText);
        }

        return textNode;
    }

    /**
     * 设置文本混合模式
     */
    private setTextBlendMode(richText: cc.RichText): void {
        // 等待下一帧确保RichText已经完全初始化
        this.scheduleOnce(() => {
            if (!richText || !richText.isValid) return;
            
            // 获取RichText的渲染组件
            const labels = richText.node.getComponentsInChildren(cc.Label);
            
            labels.forEach(label => {
                if (label && label.isValid) {
                    // 直接设置Label组件的混合模式
                    try {
                        // 设置混合因子 - 使用Label的内置属性
                        (label as any).srcBlendFactor = 1;    // ONE
                        (label as any).dstBlendFactor = 771;  // ONE_MINUS_SRC_ALPHA
                        
                        // 尝试通过渲染组件设置
                        const node = label.node;
                        if (node && (node as any)._renderComponent) {
                            const renderComp = (node as any)._renderComponent;
                            if (renderComp && renderComp.setBlend) {
                                renderComp.setBlend(1, 771); // ONE, ONE_MINUS_SRC_ALPHA
                            }
                        }
                        
                        // 强制更新渲染状态
                        label.setMaterial(0, label.getMaterial(0));
                    } catch (error) {
                        console.warn('Failed to set blend mode for label:', error);
                    }
                }
            });
        }, 0);
    }

    /**
     * 创建图片节点
     */
    private createImageNode(imagePath: string): cc.Node {
        const imageNode = new cc.Node('ImageBlock');
        const sprite = imageNode.addComponent(cc.Sprite);
        
        // 加载图片资源
        cc.resources.load(imagePath, cc.SpriteFrame, (err, spriteFrame: cc.SpriteFrame) => {
            if (!err && sprite && sprite.isValid) {
                sprite.spriteFrame = spriteFrame;
            }
        });

        return imageNode;
    }

    /**
     * 清理已生成的节点
     */
    private clearGeneratedNodes(): void {
        this.generatedNodes.forEach(node => {
            if (node && node.isValid) {
                node.destroy();
            }
        });
        this.generatedNodes = [];
    }

    /**
     * 检查是否有下一段
     */
    private hasNextChunk(): boolean {
        return this.currentChunkIndex < this.contentChunks.length - 1;
    }

    /**
     * 加载指定分段
     */
    public loadChunk(chunkIndex: number): void {
        if (this.isLoading || chunkIndex >= this.contentChunks.length) {
            return;
        }

        this.isLoading = true;
        
        this.scheduleOnce(() => {
            this.generateContent(chunkIndex);
            this.isLoading = false;
        }, 0.1);
    }

    /**
     * 加载下一段内容
     */
    public loadNextChunk(): void {
        if (this.currentChunkIndex < this.contentChunks.length - 1) {
            this.loadChunk(this.currentChunkIndex + 1);
        }
    }

    /**
     * 加载上一段内容
     */
    public loadPreviousChunk(): void {
        if (this.currentChunkIndex > 0) {
            this.loadChunk(this.currentChunkIndex - 1);
        }
    }

    /**
     * 加载完整内容
     */
    public loadFullContent(): void {
        if (this.isLoading) return;

        this.isLoading = true;
        this.clearGeneratedNodes();
        
        this.scheduleOnce(() => {
            // 生成所有内容
            for (let i = 0; i < this.contentChunks.length; i++) {
                this.generateContent(i, i > 0);
            }
            this.currentChunkIndex = this.contentChunks.length - 1;
            this.isLoading = false;
        }, 0.1);
    }

    /**
     * 添加自定义内容项
     */
    public addContentItem(chunkIndex: number, item: ContentItem, position?: number): void {
        if (chunkIndex >= 0 && chunkIndex < this.contentChunks.length) {
            if (position !== undefined) {
                this.contentChunks[chunkIndex].splice(position, 0, item);
            } else {
                this.contentChunks[chunkIndex].push(item);
            }
        }
    }

    /**
     * 获取当前分段信息
     */
    public getCurrentChunkInfo(): {current: number, total: number} {
        return {
            current: this.currentChunkIndex + 1,
            total: this.contentChunks.length
        };
    }

    /**
     * 重置到第一段
     */
    public resetToFirstChunk(): void {
        this.loadChunk(0);
    }

    /**
     * 检查是否正在加载
     */
    public isContentLoading(): boolean {
        return this.isLoading || this.isAutoLoading;
    }

    /**
     * 设置滚动阈值
     */
    public setScrollThreshold(threshold: number): void {
        this.scrollThreshold = Math.max(0.5, Math.min(1, threshold));
    }

    protected onDestroy(): void {
        // 清理事件监听
        if (this.scrollView) {
            this.scrollView.node?.off('scroll-to-bottom', this.onScrollToBottom, this);
            this.scrollView.node?.off('scrolling', this.onScrolling, this);
        }
        
        // 清理生成的节点
        this.clearGeneratedNodes();
    }
}
